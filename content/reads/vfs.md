---
title: "The SQLite OS Interface or \"VFS\""
description: 'The following is an explanation of *VFS* - Virtual File System, the agnostic layer that enables **SQLite** to be used and thus portable in any operating system.'
summary: "This article describes the SQLite OS portability layer or \"VFS\" - the module at the bottom of the SQLite implementation stack that provides portability across operating systems."
keywords: ['sqlite', 'vfs', 'file system']
date: 2023-02-07T13:02:46+0000
draft: false
categories: ['reads']
tags: ['reads', 'sqlite', 'vfs', 'file system']
---

The following is an explanation of *VFS* - Virtual File System, the agnostic layer that enables **SQLite** to be used and thus portable in any operating system. The concept is similar to the Java Virtual Machine (JVM), altough that in this case is not to execute database operations, but rather to know where and how to store database files. SQLite allows to include different VFS at start and runtime, allowing developers to create custom ways to read and write files on their target operating system (e.g., in Windows, you can use the `win32-longpath` VFS to bypass the **255** character limit in path names).

https://www.sqlite.org/vfs.html

---

1\. Introduction
================

This article describes the SQLite OS portability layer or "VFS" - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.

2\. The VFS In Relation To The Rest Of SQLite
=============================================

{{< center-figure
    src="https://raw.githubusercontent.com/freitzzz/cinderela/master/blog/general/vfs/vfs1.gif"
    caption=""
    alt=``
    class="row flex-center"
>}}

The internal organization of the SQLite library can be viewed as the stack of modules shown to the right. The Tokenizer, Parser, and Code Generator components are used to process SQL statements and convert them into executable programs in a virtual machine language or byte code. Roughly speaking, these top three layers implement [sqlite3\_prepare\_v2()](https://www.sqlite.org/c3ref/prepare.html). The byte code generated by the top three layers is a [prepared statement](https://www.sqlite.org/c3ref/stmt.html). The Virtual Machine module is responsible for running the SQL statement byte code. The B-Tree module organizes a database file into multiple key/value stores with ordered keys and logarithmic performance. The Pager module is responsible for loading pages of the database file into memory, for implementing and controlling transactions, and for creating and maintaining the journal files that prevent database corruption following a crash or power failure. The OS Interface is a thin abstraction that provides a common set of routines for adapting SQLite to run on different operating systems. Roughly speaking, the bottom four layers implement [sqlite3\_step()](https://www.sqlite.org/c3ref/step.html).

This article is about the bottom layer.

The OS Interface - also called the "VFS" - is what makes SQLite portable across operating systems. Whenever any of the other modules in SQLite needs to communicate with the operating system, they invoke methods in the VFS. The VFS then invokes the operating-specific code needed to satisfy the request. Hence, porting SQLite to a new operating system is simply a matter of writing a new OS interface layer or "VFS".

3\. Multiple VFSes
==================

The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the [sqlite3\_vfs\_register()](https://www.sqlite.org/c3ref/vfs_find.html) interface.

Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate [database connections](https://www.sqlite.org/c3ref/sqlite3.html) within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the [ATTACH](https://www.sqlite.org/lang_attach.html) command, then each attached database might be using a different VFS.

3.1. Standard Unix VFSes
------------------------

Unix builds come with multiple built-in VFSes. The default VFS for unix is called "unix" and is used in most applications. Other VFSes that might be found in unix (depending on compile-time options) include:

1.  **unix-dotfile** - uses dot-file locking rather than POSIX advisory locks.
    
2.  **unix-excl** - obtains and holds an exclusive lock on database files, preventing other processes from accessing the database. Also keeps the [wal-index](https://www.sqlite.org/walformat.html#shm) in heap rather than in shared memory.
    
3.  **unix-none** - all file locking operations are no-ops.
    
4.  **unix-namedsem** - uses named semaphores for file locking. VXWorks only.
    

The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: [os\_unix.c](http://www.sqlite.org/src/doc/trunk/src/os_unix.c). Note that except for "unix" and "unix-excl", the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The "unix-none" VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only "unix" or "unix-excl" unless there is a compelling reason to do otherwise.

3.2. Standard Windows VFSes
---------------------------

Windows builds also come with multiple built-in VFSes. The default Windows VFS is called "win32" and is used in most applications. Other VFSes that might be found on windows builds include:

1.  **win32-longpath** - like "win32" except that pathnames can be up to 65534 bytes in length, whereas pathnames max out at 1040 bytes in "win32".
    
2.  **win32-none** - all file locking operations are no-ops.
    
3.  **win32-longpath-none** - combination of "win32-longpath" and "win32-none" - long pathnames are supported and all lock operations are no-ops.
    

As with unix, most of the code for the various Windows VFSes is shared.

3.3. Specifying Which VFS To Use
--------------------------------

There is always one VFS which is the default VFS. On unix systems, the "unix" VFS comes up as the default and on windows it is "win32". If no other actions are taken, new database connections will make use of the default VFS.

The default VFS can be changed by registering or re-registering the VFS using the [sqlite3\_vfs\_register()](https://www.sqlite.org/c3ref/vfs_find.html) interface with a second parameter of 1. Hence, if a (unix) process wants to always use the "unix-nolock" VFS in place of "unix", the following code would work:

> sqlite3\_vfs\_register(sqlite3\_vfs\_find("unix-nolock"), 1);

An alternate VFS can also be specified as the 4th parameter to the [sqlite3\_open\_v2()](https://www.sqlite.org/c3ref/open.html) function. For example:

> int rc = sqlite3\_open\_v2("demo.db", &db, SQLITE\_OPEN\_READWRITE, "unix-nolock");

Finally, if [URI filenames](https://www.sqlite.org/uri.html) have been enabled, then the alternative VFS can be specified using the "vfs=" parameter on the URI. This technique works with [sqlite3\_open()](https://www.sqlite.org/c3ref/open.html), [sqlite3\_open16()](https://www.sqlite.org/c3ref/open.html), [sqlite3\_open\_v2()](https://www.sqlite.org/c3ref/open.html), and when a new database is [ATTACH](https://www.sqlite.org/lang_attach.html)\-ed to an existing database connection. For example:

> ATTACH 'file:demo2.db?vfs=unix-none' AS demo2;

The VFS specified by a URI has the highest priority. After that comes a VFS specified as the fourth argument to [sqlite3\_open\_v2()](https://www.sqlite.org/c3ref/open.html). The default VFS is used if no VFS is specified otherwise.

3.4. VFS Shims
--------------

From the point of view of the uppers layers of the SQLite stack, each open database file uses exactly one VFS. But in practice, a particular VFS might just be a thin wrapper around another VFS that does the real work. We call a wrapper VFS a "shim".

A simple example of a shim is the "vfstrace" VFS. This is a VFS (implemented in the [test\_vfstrace.c](http://www.sqlite.org/src/doc/trunk/src/test_vfstrace.c) source file) that writes a message associated with each VFS method call into a log file, then passes control off to another VFS to do the actual work.

3.5. Other Example VFSes
------------------------

The following are other VFS implementations available in the public SQLite source tree:

*   [appendvfs.c](http://www.sqlite.org/src/file/ext/misc/appendvfs.c) - This VFS allows an SQLite database to be appended to the end of some other file. This can be used, for example, to append an SQLite database onto the end of an executable such that, when run, it can easily locate the appended database. The [command-line shell](https://www.sqlite.org/cli.html) will use this VFS if launched with the --append option, and its .archive command will use it given the --append flag.
    
*   [test\_demovfs.c](http://www.sqlite.org/src/doc/trunk/src/test_demovfs.c) - This file implements a very simple VFS named "demo" that uses POSIX functions such as open(), read(), write(), fsync(), close(), fsync(), sleep(), time(), and so forth. This VFS only works on unix systems. But it is not intended as a replacement for the standard "unix" VFS used by default on unix platforms. The "demo" VFS is deliberately kept very simple so that it can be used as a learning aid or as template for building other VFSes or for porting SQLite to new operating systems.
    
*   [test\_quota.c](http://www.sqlite.org/src/doc/trunk/src/test_quota.c) - This file implements a shim called "quota" that enforces cumulative file size limits on a collection of database files. An auxiliary interface is used to define "quota groups". A quota group is a set of files (database files, journals, and temporary files) whose names all match a [GLOB](https://www.sqlite.org/lang_expr.html#glob) pattern. The sum of the sizes of all files in each quota group is tracked, and if that sum exceeds a threshold defined for the quota group, a callback function is invoked. That callback can either increase the threshold or cause the operation that would have exceeded the quota to fail with an [SQLITE\_FULL](rescode.html#full) error. One of the uses of this shim is used to enforce resource limits on application databases in Firefox.
    
*   [test\_multiplex.c](http://www.sqlite.org/src/doc/trunk/src/test_multiplex.c) - This file implements a shim that allows database files to exceed the maximum file size of the underlying filesystem. This shim presents an interface to the upper six layers of SQLite that makes it look like very large files are being used, when in reality each such large file is split up into many smaller files on the underlying system. This shim has been used, for example, to allow databases to grow larger than 2 gibibytes on FAT16 filesystems.
    
*   [test\_onefile.c](http://www.sqlite.org/src/doc/trunk/src/test_onefile.c) - This file implements a demonstration VFS named "fs" that shows how SQLite can be used on an embedded device that lacks a filesystem. Content is written directly to the underlying media. A VFS derived from this demonstration code could be used by a gadget with a limited amount of flash memory to make SQLite behave as the filesystem for the flash memory on the device.
    
*   [test\_journal.c](http://www.sqlite.org/src/doc/trunk/src/test_journal.c) - This file implements a shim used during SQLite testing that verifies that the database and rollback journal are written in the correct order and are "synced" at appropriate times in order to guarantee that the database can recover from a power lose are hard reset at any time. The shim checks several invariants on the operation of databases and rollback journals and raises exceptions if any of those invariants are violated. These invariants, in turn, assure that the database is always recoverable. Running a large suite of test cases using this shim provides added assurance that SQLite databases will not be damaged by unexpected power failures or device resets.
    
*   [test\_vfs.c](http://www.sqlite.org/src/doc/trunk/src/test_vfs.c) - This file implements a shim that can be used to simulate filesystem faults. This shim is used during testing to verify that SQLite responses sanely to hardware malfunctions or to other error conditions such as running out of filesystem space that are difficult to test on a real system.
    

There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.

4\. VFS Implementations
=======================

A new VFS is implemented by subclassing three objects:

*   [sqlite3\_vfs](https://www.sqlite.org/c3ref/vfs.html)
*   [sqlite3\_io\_methods](https://www.sqlite.org/c3ref/io_methods.html)
*   [sqlite3\_file](https://www.sqlite.org/c3ref/file.html)

An [sqlite3\_vfs](https://www.sqlite.org/c3ref/vfs.html) object defines the name of the VFS and the core methods that implement the interface to the operating system, such as checking for existence of files, deleting files, creating files and opening and for reading and/or writing, converting filenames into their canonical form. The [sqlite3\_vfs](https://www.sqlite.org/c3ref/vfs.html) object also contains methods for obtaining randomness from the operating system, for suspending a process (sleeping) and for finding the current date and time.

The [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) object represents an open file. The xOpen method of [sqlite3\_vfs](https://www.sqlite.org/c3ref/vfs.html) constructs an [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) object when the file is opened. The [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) keeps track of the state of the file while it is opened.

The [sqlite3\_io\_methods](https://www.sqlite.org/c3ref/io_methods.html) object holds the methods used to interact with an open file. Each [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) contains a pointer to an [sqlite3\_io\_methods](https://www.sqlite.org/c3ref/io_methods.html) object that is appropriate for the file it represents. The [sqlite3\_io\_methods](https://www.sqlite.org/c3ref/io_methods.html) object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) object.

Writing the code for a new VFS involves constructing a subclass for the [sqlite3\_vfs](https://www.sqlite.org/c3ref/vfs.html) object and then registering that VFS object using a call to [sqlite3\_vfs\_register()](https://www.sqlite.org/c3ref/vfs_find.html). The VFS implementation also provides subclasses for [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) and [sqlite3\_io\_methods](https://www.sqlite.org/c3ref/io_methods.html) but those objects are not registered directly with SQLite. Instead, the [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) object is returned from the xOpen method of [sqlite3\_vfs](https://www.sqlite.org/c3ref/vfs.html) and the [sqlite3\_file](https://www.sqlite.org/c3ref/file.html) object points to an instance of the [sqlite3\_io\_methods](https://www.sqlite.org/c3ref/io_methods.html) object.